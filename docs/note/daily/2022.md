# 2022

## 二月

### 闭包的另一种思考

一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）—— [闭包 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

最近在看 《JavaScript 设计模式与开发实践》中提到一点也很有意思：

> 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。

PS：不过我觉得这个描述有点奇怪，另外一点，在我看来（也不准确），对象写法的方法中，使用了 `this.count` ，也可以认为是其周围状态，所以也可以认为这是一种闭包技术吗？

**闭包写法**

通过 chrome 调试可以发现，会产生一个叫 `Closure(foo)` 的 Scope，内部是 `{ count: 0 }`

```js
function foo () {
  let count = 0
  return {
    increase: () => {
      count++
      return count
    }
  }
}
const counter = foo()
counter.increase() // -> 1
counter.increase() // -> 2
```

**对象写法**

通过 chrome 调试可以发现，会产生一个叫 `Closure(./src/index.js)` 的 Scope，内部是 `{ count: 0, increase: increase() }`

```js
const counter = {
  count: 0,
  increase: function () {
    this.count++
    return this.count
  }
}
counter.increase() // -> 1
counter.increase() // -> 2
```

## 一月

### TS 的异常捕获

因为在 js 中，任何异常都有可能被抛出

```ts
throw "What a weird error";
throw 404;
throw new Error("What a weird error");
```

所以当你 `catch(e: TypeError)` 类似这样的时候 ts 会报 **TS1196** Catch clause variable type annotation must be ‘any’ or ‘unknown’ if specified.

考虑下面的方式写：

```ts
try {
  myroutine(); // There's a couple of errors thrown here
} catch (e) {
  if (e instanceof TypeError) {
    // A TypeError
  } else if (e instanceof RangeError) {
    // Handle the RangeError
  } else if (e instanceof EvalError) {
    // you guessed it: EvalError
  } else if (typeof e === "string") {
    // The error is a string
  } else if (axios.isAxiosError(e)) {
    // axios does an error check for us!
  } else {
    // everything else  
    logMyErrors(e);
  }
}
```

Promise 也是一样的，`reject` 允许你传入任何类型。

### IOS 滚动穿透问题

很早之前就遇到过这个问题，明明整个页面都 `overflow:hidden` 了，但是当 ios 虚拟键盘唤起时，整个页面确又可以滑动了。

可以通过阻止 `touchemove` 事件来避免。

```jsx
const handler = e => e.preventDefault()

<input
  onFocus={() => {
    document.body.addEventListener('touchmove', handler, { passive: false })
  }}
  onBlur={() => {
    document.body.removeEventListener('touchmove', handler, { passive: false })
  }}
/>
```

`e.preventDefault()` 阻止默认事件。

`passive`  为 true 时， listener 将永远不会调用 `preventDefault()`（即为 true 时，是无法阻止默认事件的手动调用了 `preventDefault` 也不会有效果，控制台会警告）。

根据规范 `passive` 属性默认为 false（允许阻止）。但是在处理某些触摸事件时，可能会阻止浏览器的主线程，导致滚动处理的性能降低，所以有些浏览器将文档级节点 `Window` `Document` `Document.body` 的 touchStart touchMove 事件的 passive 默认值改为 true。

​	
