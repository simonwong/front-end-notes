# 2022

## 一月

### TS 的异常捕获

因为在 js 中，任何异常都有可能被抛出

```ts
throw "What a weird error";
throw 404;
throw new Error("What a weird error");
```

所以当你 `catch(e: TypeError)` 类似这样的时候 ts 会报 **TS1196** Catch clause variable type annotation must be ‘any’ or ‘unknown’ if specified.

考虑下面的方式写：

```ts
try {
  myroutine(); // There's a couple of errors thrown here
} catch (e) {
  if (e instanceof TypeError) {
    // A TypeError
  } else if (e instanceof RangeError) {
    // Handle the RangeError
  } else if (e instanceof EvalError) {
    // you guessed it: EvalError
  } else if (typeof e === "string") {
    // The error is a string
  } else if (axios.isAxiosError(e)) {
    // axios does an error check for us!
  } else {
    // everything else  
    logMyErrors(e);
  }
}
```

Promise 也是一样的，`reject` 允许你传入任何类型。

### IOS 滚动穿透问题

很早之前就遇到过这个问题，明明整个页面都 `overflow:hidden` 了，但是当 ios 虚拟键盘唤起时，整个页面确又可以滑动了。

可以通过阻止 `touchemove` 事件来避免。

```jsx
const handler = e => e.preventDefault()

<input
  onFocus={() => {
    document.body.addEventListener('touchmove', handler, { passive: false })
  }}
  onBlur={() => {
    document.body.removeEventListener('touchmove', handler, { passive: false })
  }}
/>
```

`e.preventDefault()` 阻止默认事件。

`passive`  为 true 时， listener 将永远不会调用 `preventDefault()`（即为 true 时，是无法阻止默认事件的手动调用了 `preventDefault` 也不会有效果，控制台会警告）。

根据规范 `passive` 属性默认为 false（允许阻止）。但是在处理某些触摸事件时，可能会阻止浏览器的主线程，导致滚动处理的性能降低，所以有些浏览器将文档级节点 `Window` `Document` `Document.body` 的 touchStart touchMove 事件的 passive 默认值改为 true。

​	
