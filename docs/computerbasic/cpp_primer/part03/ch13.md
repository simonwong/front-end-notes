# 第 13 章：拷贝控制



当定义一个类时，我们可以显式或隐式地指定此对象的拷贝、移动、赋值和销毁时做什么。

通过定义五种特殊的成员函数来控制：

- 拷贝构造函数（copy constructor）

  用同类型的另一个对象初始化

- 拷贝赋值运算符（copy-assignment operator）

  将对象赋予同类型的另一个对象

- 移动构造函数（move constructor）

  用同类型的另一个对象初始化

- 移动赋值运算符（move-assignment operator）

  将对象赋予同类型的另一个对象

- 析构函数（destructor）

  对象销毁时

## 13.1 拷贝、赋值与销毁

### 拷贝构造函数

```c++
class Foo {
public:
  Foo();
  Foo(const Foo&); // 拷贝构造函数
}
```

#### 合成构造函数

合成拷贝构造函数（synthesized copy constructor）会将其参数成员逐个拷贝到正在创建的对象中。

#### 拷贝初始化

```c++
string s1(10, `.`); // 直接初始化
string s2(s1); // 直接

string s3 = s2; // 拷贝初始化
string s4 = "Hello World"; // 拷贝
string s5 = string(10, `9`)； // 拷贝
```

不仅在使用 `=` 时

- 将对象作为实参传递一个非引用类型的形参
- 返回类型为非引用类型的函数返回一个对象
- 花括号列表初始化一个数组中的元素或一个聚合类中的成员

### 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值

#### 重载赋值运算符

```c++
class Foo {
public:
  Foo& operator=(const Foo&);
}
```

赋值运算符通常应该返回一个指向其左侧运算对象的引用。

#### 合成拷贝赋值运算符

右侧的每个非 static 成员赋予左侧对象的对应成员。

### 析构函数

析构函数释放对象的资源，并销毁对象的非 static 数据成员。

由于析构函数不接受参数，因此它不能被重载。

```c++
class Foo {
public:
  ~Foo();
}
```

隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象。

#### 什么时候会调用析构函数

对象被销毁时

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器被销毁时，其元素被销毁
- 动态分配的对象，使用了 delete
- 临时对象，创建它的完整表达式结束时



当指向一个对象的引用或指针离开作用域时，析构函数不会执行。



#### 合成析构函数

未定义自己的析构函数，编译器会为它定义一个析构函数。

### 三/五法则

在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。

**如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。**

**如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。**

### 使用 =default 

我们只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）。将会显式的要求编译器生成合成版本。

### 阻止拷贝

大多数类都应该隐式或显式的定义默认构造函数、拷贝构造函数、拷贝赋值运算符。

#### 定义删除的函数

通过将拷贝构造函数、拷贝赋值运算符定义为删除的函数，来阻止拷贝。

```c++
struct NoCopy {
  NoCopy() = default;
  NoCopy (const NoCopy&) = delete;
  NoCopy &operator=(const NoCopy&) = delete;
  ~NoCopy() = default;
}
```

#### 析构函数不能是删除的成员

如果析构函数被删除就无法销毁此类型的对象了。



如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。

本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

#### private拷贝控制

在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝。

## 13.2 拷贝控制和资源管理

### 行为像值的类

- 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针
- 定义一个析构函数来释放 string
- 定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝 string

当你编写赋值运算符时，有两点需要记住：

- 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
- 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

### 行为像指针的类

- 定义拷贝构造函数和拷贝赋值函数，拷贝指针本身，而不是值
- 析构函数不能单方面释放，之后最后一个类销毁才释放

使用**引用计数**。（达到类似 shared_ptr 的效果）

## 13.3 交换操作

swap 函数应该调用 swap，而不是 `std::swap`

使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。

## 13.4 拷贝控制示例



## 13.5 动态内存管理

### StrVec 类

- elements 指向首元素
- first_free 指向实际元素之后的位置
- cap 指向分配内存末尾之后的位置



- alloc 静态成员 `allocator<string>`
  - alloc_n_copy 分配内存，并拷贝一个给定范围中的元素
  - free 销毁构造的元素并释放内存
  - chk_n_alloc 保证 StrVec 至少容纳一个新元素的空间，没有空间就会调用 reallocate 来分配更多内存



## 13.6 对象移动

标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝。IO 类和 unique_ptr 类可以移动但不能拷贝。

### 右值引用

右值引用的重要性质：只能绑定到一个将要销毁的对象。

一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。

左值持久；右值短暂。

右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。

#### 标准库move函数

调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。

使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。



### 移动构造函数和移动赋值运算符

```c++
StrVec::StrVec(StrVec &&s) noexcept {}
```

noexcept 是通知标准库我们的构造函数不抛出任何异常。

#### 移动操作、标准库容器和异常

#### 移动赋值运算符

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept {
  // 1. 自赋值检测 this != &rhs
  // 2. 释放已有元素
  // 3. 从 rhs 接管资源
  // 4. 将 rhs 置于可析构状态
}
```

#### 移后源对象必须可析构

在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。

#### 合成的移动操作

只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。

#### 移动右值，拷贝左值...但如果没有移动构造函数，右值也被拷贝

#### 三五法则

如果一个类定义了任何一个拷贝操作，就应该定义所有五个操作。



在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用`std::move`。





## 总结

如果一个类需要析构函数，则它几乎肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运算符。
