# 数据结构

## 概念

线性表：就是数据排成像一条线一样的结构。数据最多只有前和后两个方向（数组、链表、队列、栈）

![](http://file.wangsijie.top/blog/20200321153234.png)

非线形表：数据之前并不是简单的前后关系。（二叉树、堆、图）

![](http://file.wangsijie.top/blog/20200321153255.png)



连续的内存空间和相同类型的数据，特性是“随机访问”。但是删除，插入非常低效，为了保证连续性，就需要做大量数据搬移工作。



## 数组 Array

> 数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。



### 低效的插入和删除

插入 或 删除：

末尾插入，时间复杂度 O(1) ；开头插入，时间复杂度 O(n)；平均情况时间复杂度 (1+2+...+n)/n = O(n)



**插入优化**：

如果数据是无序的，不用管排序，那么，可以把插入位置 x 替换为新的值，再把旧值放入最后。

![](http://file.wangsijie.top/blog/20200321154603.png)

这样时间复杂度就会降到 O(1)



**删除优化**：

在不一定追求连续的时候，多次删除时，让他们集中删除。每次删除标记数据被删除，但不真正搬移数据，当数组没有更多空间，再一次性删除。

比如 JVM 标记清除垃圾回收算法的核心思想。



### 区别

链表：适合插入、删除，时间复杂度是 O(1)

数组：支持随机访问，根据下标随机访问的时间复杂度为 O(1)





## 链表 Linked List

时间复杂度

- 插入删除: `O(1)`

- 随机访问: `O(n)`

空间复杂度

- `O(n)`





## 跳表 Skip List

一种动态的数据结构



时间复杂度：

- 随机访问：`O(㏒n)`
- 插入删除：`O(1)`



![](http://file.wangsijie.top/blog/20200602203729.png)

 Redis 的有序集合是通过跳表来实现的：

- 插入一个数据
- 删除一个数据
- 查找一个数据
- 按照区间查找
- 迭代输出有序序列



## 散列表

哈希表的关键思想是使用哈希函数`将键映射到存储桶`。

- 插入 key 时，根据哈希函数决定分配到哪个桶
- 查找 key 时，根据哈希函数查找对应的桶



如下，使用哈希函数 `y = x % 5` 作为哈希函数的结果。**x 是键值，y 是分配的桶的索引**

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/09/06/screen-shot-2018-02-19-at-183537.png)

哈希函数决定**键值范围**和**桶的数量**



**一个好的散列函数：**

```js
const hash = (key, tableSize) => {
	let hashVal = 0;
	
	for (let i = 0; i < key.length; i++) {
		hashVal = 37 * hashVal + key.charCodeAt(i)
	}

	hashVal %= tableSize;

	if (hashVal < 0) {
		hashVal += tableSize
	}
	return hashVal
}
```



### 解决散列冲突的方式

- 分离链接法
- 不用链表
  - 线性探测法
  - 平方探测法
  - 双散列
- 再散列
- 布谷鸟散列
- 跳房子散列
- 通用散列



## 树



### 二叉树

![](http://file.wangsijie.top/blog/20200808111444.jpg)



前序遍历：ABDECFG
中序遍历：DBEAFCG
后序遍历：DEBFGCA
层序遍历：ABCDEFG



**前序遍历**（先序遍历） ：

```js
/**
 * 前序遍历 -- 递归写法
 */
const preOrder = (root) => {
  if (root == null) {
    return;
  }
  console.log(root.val)
  preOrder(root.left);
  preOrder(root.right);
}
```

```js
/**
 * 前序遍历 -- 利用栈 迭代
 */
const preOrder = (root) => {

}
```



**中序遍历**

如果是二叉搜索树，在中序遍历的值就是递增排序

```js
/**
 * 中序遍历 -- 递归写法
 */
const inOrder = (root) => {
  if (root == null) {
    return;
  }
  inOrder(root.left);
  console.log(root.val)
  inOrder(root.right);
}
```

```js
/**
 * 中序遍历 -- 利用栈 迭代
 */
const inOrder = (root) => {
 	const stack = []
  const cur = root
    
  while (cur != null || stack.length > 0) {
    while(cur != null) {
      stack.push(cur)
      cur = cur.left
    }
    cur = cur.pop()
    console.log(cur.val)
    cur = cur.right
  }
}
```



**后序遍历**

```js
/**
 * 后序遍历 -- 递归写法
 */

const postOrder = (root) => {
  if (root == null) {
    return
  }
  postOrder(root.left)
  postOrder(root.right)
  console.log(root.val)
}
```

```js
/**
 * 后序遍历 -- 利用栈 迭代
 */
const postOrder = (root) => {
}
```



**层序遍历**

```js
/**
 * 层序遍历 -- 利用队列辅助
 */
const levelOrder = (root) => {
  const queue = []
  queue.push(root)
  while (queue.length > 0) {
    const cur = queue.shift()
    console.log(cur.val)
    if (cur.left) {
      queue.push(cur.left)
    }
    if (cur.right) {
      queue.push(cur.right)
    }
  }
}
```

